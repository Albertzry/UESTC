# **2.引入idle线程的调度**

在上一道题目“简单ready队列调度”的基础上，我们继续来完善调度算法。请大家思考下，如果用户没有向操作系统提交任何任务时，CPU在做什么呢？事实上CPU是在不停地执行指令的，为此操作系统都引入了idle线程的概念，当ready队列中没有线程可调度时则执行idle线程；一旦下一次进行调度时操作系统发现ready队列中有线程等待调度，就会由idle线程的执行切换到ready队列中等待执行的线程进行执行。在Windows等主流操作系统的实现中，都不将idle线程放入ready队列中，因此我们的模拟实验也遵循了这个要求（同学们可以想一想它们为什么这么设计？）
另外这道题目还要求同学们实现“线程运行结束”的功能，当该函数被调用后，表示当前线程（即current_thread指针指向的线程）已经完成了任务，不再参与后续调度了。（请大家想一想，为什么线程结束函数只能结束当前线程，如果实现了可以结束其他线程，会不会有什么风险？）本题目需要实现使用先到先服务的调度算法管理ready队列，并实现对idle线程的调度和结束当前正在运行的线程的功能。需要实现的函数及功能描述如下：
1.void add_ready_thread(thread* ready_thread)：向ready队列中添加一个新的线程对象指针，该函数本身不发起调度。
2.void schedule()：实现调度算法，按“先到先服务”的算法调度ready队列中的线程，选取合适的线程对象指针放入current_thread全局变量中（需要按需完成对idle线程的调度）
3.void current_thread_finished()：current_thread指向的线程已经完成运行，不再参与后续调度，并且重新发起调度。
需要注意的是：
1.idle线程对应的结构体实例为idle_thread，同学们不需要再定义了，在包含thread_hdr.h头文件后可以直接使用。
2.本题不要求对调用current_thread_finished()后完成运行的线程进行管理。
3.在提交代码时，请只提交包含如下内容的源文件，不要提交thread_hdr.h以及用于测试的thread_tester.cpp，否则会导致不通过编译而无法得分。若提交后仅拿到部分分数，请仔细阅读题目要求并确认实现细节特别是边界条件。