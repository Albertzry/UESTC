# **3.引入阻塞的线程调度**

请对照实验指导书实验三，在实验二已完成的代码基础上进行修改，编写C++程序实现操作系统实验课程中的包含阻塞和唤醒语义的先到先服务调度算法。在实验二的基础上新增如下要求：
1.本题目使用C++标准库中的deque<thread*>表示阻塞队列，阻塞队列已经在测试代码中定义过了，名为blocked_queue，请同学们使用该队列而不要重新定义新的队列，否则可能导致编译不通过而无法获取到分数。thread_student.cpp已经包含了thread_hdr.h头文件，可以直接使用该变量。
2.阻塞队列的管理依然采用先到先服务的原则，即被阻塞的线程依次在队尾排队，而从队头取得被唤醒的线程。唤醒单个线程和唤醒所有线程都遵循此规则。
本题目需要实现的函数及功能描述如下：
1.实验二中已实现的各函数（请详细对照实验指导书上的要求确认是否要对已有代码进行修改）
2.void current_thread_blocked()：调用此函数意味着current_thread指向的线程将处于阻塞态，被加入到阻塞队列中，暂时不再参与后续调度（直到被唤醒），并且重新发起调度。
3.void notify()：调用此函数意味着从阻塞队列的头部唤醒一个被阻塞的线程。
4.void notify_all()：调用此函数意味着从阻塞队列唤醒所有被阻塞的线程。
注意：在提交代码时，请只提交包含如下内容的源文件，不要提交thread_hdr.h以及thread_tester.cpp，否则会导致不通过编译而无法得分。若提交后仅拿到部分分数，请仔细阅读题目要求并确认实现细节特别是边界条件。